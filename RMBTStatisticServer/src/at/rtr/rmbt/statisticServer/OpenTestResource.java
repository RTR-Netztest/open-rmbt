/*******************************************************************************
 * Copyright 2013-2016 alladin-IT GmbH
 * Copyright 2013-2016 Rundfunk und Telekom Regulierungs-GmbH (RTR-GmbH)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package at.rtr.rmbt.statisticServer;

import at.rtr.rmbt.statisticServer.opendata.dao.OpenTestDAO;
import at.rtr.rmbt.statisticServer.opendata.dto.*;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiImplicitParam;
import io.swagger.annotations.ApiImplicitParams;
import io.swagger.annotations.ApiOperation;
import org.restlet.data.Form;
import org.restlet.data.Status;
import org.restlet.resource.Get;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import java.util.logging.Logger;


@Api(value="/opentests/")
public class OpenTestResource extends ServerResource
{
    //maximum of rows sent in one single request
    public final int MAXROWS = 400;

    /**
     * disable/enable smoothing of returned curves
     */
    public final static boolean RETURN_SMOOTHED_SPEED_CURVES = false;

    /**
     * data amount for centered moving average must not be < 3 and odd.
     * The function needs x values on the "left" and "right side" of the current value, where x = (SMOOTHING_DATA_AMOUNT-1)/2
     * f(i) = 1/x * (e[i-x] + e[i-x+1] + ... + e[i] + ... + e[i+x-1] + e[i+x])
     */
    public final static int SMOOTHING_DATA_AMOUNT = 5;

    @Path("/opentests/{open-test-uuid}")
    @ApiOperation(value = "query for OpenTests",
            notes = "Query for a specific measurement result",
            response = OpenTestDetailsDTO.class,
            httpMethod = "GET",
            nickname = "opentest-query")
    @GET
    @Get("json")
    @ApiImplicitParams({
            @ApiImplicitParam(name = "open-test-uuid", value = "Mandatory. The open-test-uuid of the test.", dataType = "string", example = "Oc1326b7c-4141-42cb-b8c5-922c356a6cee", paramType = "path", required = true),
            @ApiImplicitParam(name = "verbose", value = "Optional. If >0 the threadwise speed curve is additionally returned.", dataType = "integer", example = "0", paramType = "query"),
            @ApiImplicitParam(name = "sender", value = "Optional. ID of the sender, for authentification.", dataType = "string", paramType = "query")
    })
    public String request(final String entity) {
        int verboseLevel = 0;
        addAllowOrigin();

        //routing should be in a way in which open_test_uuid is always set
        String openUUID = getRequest().getAttributes().get("open_test_uuid").toString();


        final Form getParameters = getRequest().getResourceRef().getQueryAsForm();
        //allow sender + verbose
        for (String name : getParameters.getNames()) {
            if (name.equals("verbose")) {
                try {
                    verboseLevel = Integer.parseInt(getParameters.getFirstValue("verbose"));
                } catch (NumberFormatException ex) {
                    Logger.getGlobal().info("invalid non-numberic verbosity level");
                }
            } else if (name.equals("sender") || name.equals("?sender")) { //allow for ?sender; used by some users due to error in old documentation
                //ignore for now
                final String sender_id;
                if (name.equals("sender"))
                    sender_id = "sender " + getParameters.getFirstValue("sender");
                else
                    sender_id = "sender " + getParameters.getFirstValue("?sender");
//        		System.out.println(sender_id);
                //the logging block would require write access to the database
        		/*
        		final String sql = "UPDATE json_sender SET count = count + 1 WHERE sender_id = ?";
        		PreparedStatement ps = null;
                try
                {
                    ps = conn.prepareStatement(sql);
                    ps.setString(1, sender_id);
                    
                    ps.executeUpdate();
                } catch  (final SQLException e)
                {
                    Logger.getLogger(OpenTestResource.class.getName()).log(Level.SEVERE, null, e);
                }
                */
            }
        }

        OpenTestDAO openTestDAO = new OpenTestDAO(conn, settings, capabilities);

        OpenTestDetailsDTO ret = openTestDAO.getSingleOpenTestDetails(openUUID, verboseLevel);
        ObjectMapper om = new ObjectMapper();
        om.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);
        String sr = null;
        try {
            sr = om.writer().writeValueAsString(ret);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            setStatus(Status.SERVER_ERROR_INTERNAL);
        }

        //set status if not found
        if (ret.getError() != null) {
            setStatus(Status.CLIENT_ERROR_NOT_FOUND);
        }

        return sr;
    }

}
